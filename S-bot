#include <Arduino.h>
#include <Arduino_FreeRTOS.h>
#include <semphr.h>
#include <NewPing.h>

/*######################################################왼쪽 바퀴*/
#define IN1 11 
#define IN2 10  
#define ENR 7

/*######################################################오른쪽 바퀴*/
#define IN3 9
#define IN4 8
#define ENL 6 

/*######################################################초음파 센서*/
// 왼쪽 센서
#define SONIC_TRIG_LEFT 34
#define SONIC_ECHO_LEFT 35
// 중앙 센서
#define SONIC_TRIG_CENTER 51
#define SONIC_ECHO_CENTER 50
// 오른쪽 센서
#define SONIC_TRIG_RIGHT 46
#define SONIC_ECHO_RIGHT 47
/*######################################################*/

// 최대 측정 거리
#define MAX_DISTANCE 200

//////////////////////////////////////////
NewPing sonarLeft(SONIC_TRIG_LEFT, SONIC_ECHO_LEFT, MAX_DISTANCE);
NewPing sonarCenter(SONIC_TRIG_CENTER, SONIC_ECHO_CENTER, MAX_DISTANCE);
NewPing sonarRight(SONIC_TRIG_RIGHT, SONIC_ECHO_RIGHT, MAX_DISTANCE);
//////////////////////////////////////////

// 태스크 핸들러 선언
TaskHandle_t control_motor_handle;
TaskHandle_t read_sonar_handle;

// 뮤텍스 선언
SemaphoreHandle_t xDistanceMutex;

// 전역 변수 - 초음파 센서 거리 값
volatile unsigned long distance_left = 0;
volatile unsigned long distance_center = 0;
volatile unsigned long distance_right = 0;

// 함수 선언
void motor_l(int speed);
void motor_r(int speed);
void robot_control(int left_motor_speed, int right_motor_speed);
void control_motor(void *pvParameters);

void read_sonar_sensor(void *pvParameters);

//////////////////////////////////////////

void setup() 
{
    // 시리얼 통신 초기화
    Serial.begin(9600);
    
    // 모터 핀 설정
    pinMode(IN1, OUTPUT);
    pinMode(IN2, OUTPUT);
    pinMode(IN3, OUTPUT);
    pinMode(IN4, OUTPUT);
    pinMode(ENL, OUTPUT);
    pinMode(ENR, OUTPUT);
    
    // 뮤텍스 생성
    xDistanceMutex = xSemaphoreCreateMutex();
    
    // read_sonar_sensor 태스크 생성
    xTaskCreate(
        read_sonar_sensor,        // 태스크 함수
        "ReadSonar",              // 태스크 이름
        128,                      // 스택 크기
        NULL,                     // 태스크 파라미터
        1,                        // 태스크 우선순위
        &read_sonar_handle        // 태스크 핸들러
    );
    
    // control_motor 태스크 생성
    xTaskCreate(
        control_motor,            // 태스크 함수
        "ControlMotor",           // 태스크 이름
        128,                      // 스택 크기
        NULL,                     // 태스크 파라미터
        2,                        // 태스크 우선순위 (높을수록 우선순위 높음)
        &control_motor_handle     // 태스크 핸들러
    );
    
    // 스케줄러 시작
    vTaskStartScheduler();
}

void loop() 
{
  
}

// 초음파 센서 읽기 태스크
void read_sonar_sensor(void *pvParameters) 
{
    Serial.println("Sonar Sensor Task Started");
    
    for (;;) 
    {
        // NewPing 라이브러리를 사용하여 각 초음파 센서에서 거리 측정
        unsigned long left = sonarLeft.ping_cm();
        unsigned long center = sonarCenter.ping_cm();
        unsigned long right = sonarRight.ping_cm();
        
        // 0 값(측정 실패)을 큰 값으로 변환
        if (left == 0) left = 9999;
        if (center == 0) center = 9999;
        if (right == 0) right = 9999;
        
        // 뮤텍스 획득
        if (xSemaphoreTake(xDistanceMutex, portMAX_DELAY) == pdTRUE) {
            // 공유 변수 업데이트
            distance_left = left;
            distance_center = center;
            distance_right = right;
            
            // 뮤텍스 해제
            xSemaphoreGive(xDistanceMutex);
        }
        
        // 거리 출력
        Serial.print("Left: ");
        Serial.print(left);
        Serial.print(" cm, Center: ");
        Serial.print(center);
        Serial.print(" cm, Right: ");
        Serial.print(right);
        Serial.println(" cm");
        
        // 다음 측정까지 대기
        vTaskDelay(pdMS_TO_TICKS(50)); // 50ms마다 측정
    }
}

// 왼쪽 모터 제어 함수
void motor_l(int speed) 
{
    if (speed >= 0) 
    {
        digitalWrite(IN1, LOW);
        digitalWrite(IN2, HIGH);
        analogWrite(ENL, speed); // 0-255
    } 
    else 
    {
        digitalWrite(IN1, HIGH);
        digitalWrite(IN2, LOW);
        analogWrite(ENL, -speed);
    }
}

// 오른쪽 모터 제어 함수
void motor_r(int speed) 
{
    if (speed >= 0) 
    {
        digitalWrite(IN3, LOW);
        digitalWrite(IN4, HIGH);
        analogWrite(ENR, speed); // 0-255
    } 
    
    else 
    {
        digitalWrite(IN3, HIGH);
        digitalWrite(IN4, LOW);
        analogWrite(ENR, -speed);
    }
}

// 로봇 제어 함수
void robot_control(int left_motor_speed, int right_motor_speed) 
{
    motor_l(left_motor_speed);
    motor_r(right_motor_speed);
}

// 모터 제어 태스크
void control_motor(void *pvParameters) 
{
    Serial.println("Motor Control Task Started");
    
    // 무한 루프로 실행
    for (;;) 
    {
        unsigned long left = 0;
        unsigned long center = 0;
        unsigned long right = 0;
        
        // 뮤텍스 획득
        if (xSemaphoreTake(xDistanceMutex, portMAX_DELAY) == pdTRUE) 
        {
            // 공유 변수 읽기
            left = distance_left;
            center = distance_center;
            right = distance_right;
            
            // 뮤텍스 해제
            xSemaphoreGive(xDistanceMutex);
        }
        

        if (center < 20) 
        {
            // 정면에 장애물이 있을 경우 정지
            Serial.println("Obstacle detected! Stopping");
            robot_control(0, 0);
            vTaskDelay(pdMS_TO_TICKS(1000)); // 1초 대기
            
            // 좌우 거리 비교 후 회전
            if (left > right) 
            {
                // 왼쪽이 더 넓으면 왼쪽으로 회전
                Serial.println("Turning left");
                robot_control(-50, 50);
            } else 
            {
                // 오른쪽이 더 넓으면 오른쪽으로 회전
                Serial.println("Turning right");
                robot_control(50, -50);
            }
            vTaskDelay(pdMS_TO_TICKS(1000)); // 1초 회전
        } 
        else 
        {
            // 정면에 장애물이 없을 경우 전진
            Serial.println("Moving forward");
            robot_control(50, 50);
            vTaskDelay(pdMS_TO_TICKS(1000)); // 1초 전진
        }
    }
}
